diff --git a/include/clang/Basic/Builtins.def b/include/clang/Basic/Builtins.def
index f9ec004..51ce4cb 100644
--- a/include/clang/Basic/Builtins.def
+++ b/include/clang/Basic/Builtins.def
@@ -1216,6 +1216,9 @@ BUILTIN(__builtin_subcl, "ULiULiCULiCULiCULi*", "n")
 BUILTIN(__builtin_subcll, "ULLiULLiCULLiCULLiCULLi*", "n")
 
 // Checked Arithmetic Builtins for Security.
+BUILTIN(__builtin_add_overflow, "v.", "nt")
+BUILTIN(__builtin_sub_overflow, "v.", "nt")
+BUILTIN(__builtin_mul_overflow, "v.", "nt")
 BUILTIN(__builtin_uadd_overflow, "bUiCUiCUi*", "n")
 BUILTIN(__builtin_uaddl_overflow, "bULiCULiCULi*", "n")
 BUILTIN(__builtin_uaddll_overflow, "bULLiCULLiCULLi*", "n")
diff --git a/include/clang/Basic/DiagnosticSemaKinds.td b/include/clang/Basic/DiagnosticSemaKinds.td
index 2d6545c..252ac80 100644
--- a/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/include/clang/Basic/DiagnosticSemaKinds.td
@@ -6189,6 +6189,11 @@ def warn_atomic_op_has_invalid_memory_order : Warning<
   "memory order argument to atomic operation is invalid">,
   InGroup<DiagGroup<"atomic-memory-ordering">>;
 
+def err_overflow_builtin_must_be_int : Error<
+  "operand argument to overflow builtin must be an integer (%0 invalid)">;
+def err_overflow_builtin_must_be_ptr_int : Error<
+  "result argument to overflow builtin must be a pointer to integer (%0 invalid)">;
+
 def err_atomic_load_store_uses_lib : Error<
   "atomic %select{load|store}0 requires runtime support that is not "
   "available for this target">;
diff --git a/lib/CodeGen/CGBuiltin.cpp b/lib/CodeGen/CGBuiltin.cpp
index 394d0d1..84be2ce 100644
--- a/lib/CodeGen/CGBuiltin.cpp
+++ b/lib/CodeGen/CGBuiltin.cpp
@@ -28,6 +28,8 @@
 #include "llvm/IR/Intrinsics.h"
 #include <sstream>
 
+#define DEBUG_TYPE "david"
+
 using namespace clang;
 using namespace CodeGen;
 using namespace llvm;
@@ -256,6 +258,52 @@ static llvm::Value *EmitOverflowIntrinsic(CodeGenFunction &CGF,
   return CGF.Builder.CreateExtractValue(Tmp, 0);
 }
 
+// Given one or more integer types, this function produces an integer type that
+// encompasses them: any value in one of the given types could be expressed in
+// the encompassing type.
+//
+// This function operates on objects of type std::pair<unsigned, bool>, where
+// the first element is the bit width of an integer type and the second element
+// is true the integer type is signed.
+//
+// The returned width could be out of bounds and should be checked.
+static std::pair<unsigned, bool> EncompassingIntegerType(
+  std::vector<std::pair<unsigned, bool>> Types)
+{
+  std::pair<unsigned, bool> EncType(0, false);
+
+  // If any of the given types is signed, we must return a signed type.
+  for(auto it = Types.begin(); it != Types.end(); ++it) {
+    EncType.second |= it->second;
+  }
+
+  // The encompassing type must have a width greater than or equal to the
+  // width of the specified types.  If the encompassing type is signed, its
+  // width must be strictly greater than the width of any signed types given.
+  for(auto it = Types.begin(); it != Types.end(); ++it) {
+    unsigned width = it->first + (EncType.second && !it->second);
+    if (EncType.first < width) {
+      EncType.first = width;
+    }
+  }
+
+  return EncType;
+}
+
+static std::pair<unsigned, bool> IntegerWidthAndSignedness(ASTContext &context,
+                                                           const clang::QualType Type)
+{
+  assert(Type->isIntegerType());
+  std::pair<unsigned, bool> Result;
+  Result.second = Type->isSignedIntegerType();
+  if (Type->isBooleanType()) {
+    Result.first = 1;
+  } else {
+    Result.first = context.getTypeInfo(Type).Width;
+  }
+  return Result;
+}
+
 RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
                                         unsigned BuiltinID, const CallExpr *E,
                                         ReturnValueSlot ReturnValue) {
@@ -1530,6 +1578,95 @@ RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
     CarryOutStore->setAlignment(CarryOutPtr.second);
     return RValue::get(Sum2);
   }
+
+  case Builtin::BI__builtin_add_overflow: {
+    const clang::Expr *XArg = E->getArg(0);
+    const clang::Expr *YArg = E->getArg(1);
+    const clang::Expr *RArg = E->getArg(2);
+
+    clang::QualType XQTy = XArg->getType();//.getCanonicalType();
+    clang::QualType YQTy = YArg->getType();//.getCanonicalType();
+    clang::QualType RQTy = RArg->getType()//.getCanonicalType()
+      ->getAs<PointerType>()->getPointeeType();
+
+    std::pair<unsigned, bool> XITy = IntegerWidthAndSignedness(CGM.getContext(), XQTy);
+    std::pair<unsigned, bool> YITy = IntegerWidthAndSignedness(CGM.getContext(), YQTy);
+    std::pair<unsigned, bool> RITy = IntegerWidthAndSignedness(CGM.getContext(), RQTy);
+    std::pair<unsigned, bool> EITy = EncompassingIntegerType({XITy, YITy, RITy});
+
+    llvm::Value *X = EmitScalarExpr(XArg);
+    llvm::Value *Y = EmitScalarExpr(YArg);
+    std::pair<llvm::Value *, unsigned> SumOutPtr = EmitPointerWithAlignment(RArg);
+
+    llvm::Type * ELTy = llvm::IntegerType::get(CGM.getLLVMContext(), EITy.first);
+
+    // RLTy and OutputLTy are usually the same, but sometimes
+    // RLTy is i1 and OutputLTy is i8.
+    llvm::Type *RLTy = CGM.getTypes().ConvertType(RQTy);
+    llvm::Type *OutputLTy = cast<llvm::PointerType>(SumOutPtr.first->getType())->getElementType();
+
+    DEBUG(dbgs() << "hi there: ");
+    DEBUG(dbgs() << XQTy.getAsString() << " ");
+    DEBUG(dbgs() << YQTy.getAsString() << " ");
+    DEBUG(dbgs() << RQTy.getAsString() << " ");
+    DEBUG(dbgs() << EITy.first << " " << EITy.second << " ");
+    DEBUG(dbgs() << "\n");
+
+    llvm::Intrinsic::ID IntrinsicId = EITy.second
+      ? llvm::Intrinsic::sadd_with_overflow
+      : llvm::Intrinsic::uadd_with_overflow;
+
+    if (XQTy->isSignedIntegerType()) {
+      X = Builder.CreateSExt(X, ELTy);
+    } else {
+      X = Builder.CreateZExt(X, ELTy);
+    }
+
+    if (YQTy->isSignedIntegerType()) {
+      Y = Builder.CreateSExt(Y, ELTy);
+    } else {
+      Y = Builder.CreateZExt(Y, ELTy);
+    }
+
+    llvm::Value *Overflow, *Sum;
+    Sum = EmitOverflowIntrinsic(*this, IntrinsicId, X, Y, Overflow);
+
+    if (EITy.first > RITy.first)
+    {
+      // The encompassing type is wider than the result type, so we need to
+      // truncate it.
+      llvm::Value * TruncSum = Builder.CreateTrunc(Sum, RLTy);
+
+      // To see if the truncation caused an overflow, we will extend/untruncate
+      // it and then compare it to the original, sum.
+      llvm::Value * ExtendedSum;
+      if (RITy.second) {
+        ExtendedSum = Builder.CreateSExt(TruncSum, ELTy);
+      } else {
+        ExtendedSum = Builder.CreateZExt(TruncSum, ELTy);
+      }
+      llvm::Value * TruncationOverflow = Builder.CreateICmpNE(Sum, ExtendedSum);
+
+      Overflow = Builder.CreateOr(Overflow, TruncationOverflow);
+      Sum = TruncSum;
+    }
+
+    //CGM.Error(E->getLocStart(),
+    //    "cannot generate code for this combination of argument types yet");
+    //  return GetUndefRValue(E->getType());
+
+    // If the result argument is a _Bool*, EmitPointerWithAlignment gives us an
+    // i8*.  If our sum is an i1, we need to zero-extend before storing.
+    if (RLTy->isIntegerTy(1)) {
+      Sum = Builder.CreateZExt(Sum, OutputLTy);
+    }
+    DEBUG(dbgs() << "hi there 3\n");
+    Builder.CreateAlignedStore(Sum, SumOutPtr.first, SumOutPtr.second);
+
+    DEBUG(dbgs() << "hi there 4\n");
+    return RValue::get(Overflow);
+  }
+
   case Builtin::BI__builtin_uadd_overflow:
   case Builtin::BI__builtin_uaddl_overflow:
   case Builtin::BI__builtin_uaddll_overflow:
diff --git a/lib/Sema/SemaChecking.cpp b/lib/Sema/SemaChecking.cpp
index a8a7009..a191036 100644
--- a/lib/Sema/SemaChecking.cpp
+++ b/lib/Sema/SemaChecking.cpp
@@ -111,6 +111,36 @@ static bool SemaBuiltinAddressof(Sema &S, CallExpr *TheCall) {
   return false;
 }
 
+static bool SemaBuiltinOverflow(Sema &S, CallExpr *TheCall) {
+  if (checkArgCount(S, TheCall, 3))
+    return true;
+
+  // First two arguments should be integers.
+  for (unsigned i = 0; i < 2; i++)
+  {
+    Expr *Arg = TheCall->getArg(i);
+    QualType Ty = Arg->getType();
+    if (!Ty->isIntegerType()) {
+      S.Diag(Arg->getLocStart(), diag::err_overflow_builtin_must_be_int)
+        << Ty << Arg->getSourceRange();
+      return true;
+    }
+  }
+
+  // Third argument should be a pointer to an integer.
+  {
+    Expr *Arg = TheCall->getArg(2);
+    QualType Ty = Arg->getType();
+    const PointerType *PtrTy = Ty->getAs<PointerType>();
+    if (!(PtrTy && PtrTy->getPointeeType()->isIntegerType())) {
+      S.Diag(Arg->getLocStart(), diag::err_overflow_builtin_must_be_ptr_int)
+        << Ty << Arg->getSourceRange();
+    }
+  }
+
+  return false;
+}
+
 static void SemaBuiltinMemChkCall(Sema &S, FunctionDecl *FDecl,
 		                  CallExpr *TheCall, unsigned SizeIdx,
                                   unsigned DstSizeIdx) {
@@ -453,6 +483,12 @@ Sema::CheckBuiltinFunctionCall(FunctionDecl *FDecl, unsigned BuiltinID,
     if (SemaBuiltinAddressof(*this, TheCall))
       return ExprError();
     break;
+  case Builtin::BI__builtin_add_overflow:
+  case Builtin::BI__builtin_sub_overflow:
+  case Builtin::BI__builtin_mul_overflow:
+      if (SemaBuiltinOverflow(*this, TheCall))
+          return ExprError();
+      break;
   case Builtin::BI__builtin_operator_new:
   case Builtin::BI__builtin_operator_delete:
     if (!getLangOpts().CPlusPlus) {
diff --git a/test/CodeGen/builtins-overflow.c b/test/CodeGen/builtins-overflow.c
index 5c5500d..bb89418 100644
--- a/test/CodeGen/builtins-overflow.c
+++ b/test/CodeGen/builtins-overflow.c
@@ -11,6 +11,19 @@ extern unsigned long long UnsignedLongLongErrorCode;
 extern int IntErrorCode;
 extern long LongErrorCode;
 extern long long LongLongErrorCode;
+void overflowed(void);
+
+unsigned test_add_overflow_uint_uint_uint(unsigned x, unsigned y) {
+// CHECK: @test_add_overflow_uint_uint_uint
+// CHECK: [[S:%.+]] = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %{{.+}}, i32 %{{.+}})
+// CHECK-NEXT: [[C:%.+]] = extractvalue { i32, i1 } [[S]], 1
+// CHECK-NEXT: [[Q:%.+]] = extractvalue { i32, i1 } [[S]], 0
+// CHECK-NEXT: store i32 [[Q:%.+]], i32* %r, align 4
+// CHECK-NEXT: br i1 [[C]]
+    unsigned r;
+    if (__builtin_add_overflow(x, y, &r)) overflowed();
+    return r;
+}
 
 unsigned test_uadd_overflow(unsigned x, unsigned y) {
 // CHECK: @test_uadd_overflow
