diff --git a/include/clang/Basic/Builtins.def b/include/clang/Basic/Builtins.def
index f9ec004..51ce4cb 100644
--- a/include/clang/Basic/Builtins.def
+++ b/include/clang/Basic/Builtins.def
@@ -1216,6 +1216,9 @@ BUILTIN(__builtin_subcl, "ULiULiCULiCULiCULi*", "n")
 BUILTIN(__builtin_subcll, "ULLiULLiCULLiCULLiCULLi*", "n")
 
 // Checked Arithmetic Builtins for Security.
+BUILTIN(__builtin_add_overflow, "v.", "nt")
+BUILTIN(__builtin_sub_overflow, "v.", "nt")
+BUILTIN(__builtin_mul_overflow, "v.", "nt")
 BUILTIN(__builtin_uadd_overflow, "bUiCUiCUi*", "n")
 BUILTIN(__builtin_uaddl_overflow, "bULiCULiCULi*", "n")
 BUILTIN(__builtin_uaddll_overflow, "bULLiCULLiCULLi*", "n")
diff --git a/include/clang/Basic/DiagnosticSemaKinds.td b/include/clang/Basic/DiagnosticSemaKinds.td
index 2afcb76..7e1c63d 100644
--- a/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/include/clang/Basic/DiagnosticSemaKinds.td
@@ -6185,6 +6185,11 @@ def warn_atomic_op_has_invalid_memory_order : Warning<
   "memory order argument to atomic operation is invalid">,
   InGroup<DiagGroup<"atomic-memory-ordering">>;
 
+def err_overflow_builtin_must_be_int : Error<
+  "operand argument to overflow builtin must be an integer (%0 invalid)">;
+def err_overflow_builtin_must_be_ptr_int : Error<
+  "result argument to overflow builtin must be a pointer to integer (%0 invalid)">;
+
 def err_atomic_load_store_uses_lib : Error<
   "atomic %select{load|store}0 requires runtime support that is not "
   "available for this target">;
diff --git a/lib/CodeGen/CGBuiltin.cpp b/lib/CodeGen/CGBuiltin.cpp
index 394d0d1..dd59a5a 100644
--- a/lib/CodeGen/CGBuiltin.cpp
+++ b/lib/CodeGen/CGBuiltin.cpp
@@ -28,6 +28,8 @@
 #include "llvm/IR/Intrinsics.h"
 #include <sstream>
 
+#define DEBUG_TYPE "david"
+
 using namespace clang;
 using namespace CodeGen;
 using namespace llvm;
@@ -256,6 +258,42 @@ static llvm::Value *EmitOverflowIntrinsic(CodeGenFunction &CGF,
   return CGF.Builder.CreateExtractValue(Tmp, 0);
 }
 
+// Given two integer types, returns true if every value having Type1
+// can be represented in Type2.
+static bool TypeRepresentableAs(ASTContext &context,
+                                const clang::QualType Type1,
+                                const clang::QualType Type2) {
+  assert(Type1->isIntegerType() && "Expected an integer type.");
+  assert(Type2->isIntegerType() && "Expected an integer type.");
+
+  bool Signed1 = Type1->isSignedIntegerType();
+  uint64_t Width1;
+  if (Type1->isBooleanType()) {
+    Width1 = 1;
+  } else {
+    Width1 = context.getTypeInfo(Type1).Width;
+  }
+
+  bool Signed2 = Type1->isSignedIntegerType();
+  uint64_t Width2;
+  if (Type1->isBooleanType()) {
+    Width2 = 1;
+  } else {
+    Width2 = context.getTypeInfo(Type2).Width;
+  }
+
+  if (Signed1 && !Signed2) {
+    return false;
+  } else if (Width2 > Width1) {
+    return true;
+  } else if (Width2 == Width1) {
+    return Signed1 == Signed2;
+  } else {
+    return true;
+  }
+}
+
+
 RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
                                         unsigned BuiltinID, const CallExpr *E,
                                         ReturnValueSlot ReturnValue) {
@@ -1530,6 +1568,83 @@ RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
     CarryOutStore->setAlignment(CarryOutPtr.second);
     return RValue::get(Sum2);
   }
+
+  case Builtin::BI__builtin_add_overflow: {
+    const clang::Expr *XArg = E->getArg(0);
+    const clang::Expr *YArg = E->getArg(1);
+    const clang::Expr *RArg = E->getArg(2);
+
+    clang::QualType XQTy = XArg->getType();
+    clang::QualType YQTy = YArg->getType();
+    clang::QualType RQTy = RArg->getType()
+      ->getAs<PointerType>()->getPointeeType();
+
+    const clang::Type *XTy = XQTy->getUnqualifiedDesugaredType();
+    const clang::Type *YTy = YQTy->getUnqualifiedDesugaredType();
+    const clang::Type *RTy = RQTy->getUnqualifiedDesugaredType();
+
+    llvm::Value *X = EmitScalarExpr(XArg);
+    llvm::Value *Y = EmitScalarExpr(YArg);
+    std::pair<llvm::Value *, unsigned> SumOutPtr = EmitPointerWithAlignment(RArg);
+
+    // RLTy and OutputLTy are usually the same, but sometimes
+    // RLTy is i1 and OutputLTy is i8.
+    llvm::Type *RLTy = CGM.getTypes().ConvertType(RQTy);
+    llvm::Type *OutputLTy = cast<llvm::PointerType>(SumOutPtr.first->getType())->getElementType();
+
+    //DEBUG(llvm::dbgs() << "hi there: ");
+    //DEBUG(llvm::dbgs() << XQualTy->getAsString() << " ");
+    //DEBUG(llvm::dbgs() << YQualTy->getAsString() << " ");
+    //DEBUG(llvm::dbgs() << RQualTy->getAsString() << "\n");
+
+    llvm::Intrinsic::ID IntrinsicId = RTy->isUnsignedIntegerType()
+      ? llvm::Intrinsic::uadd_with_overflow
+      : llvm::Intrinsic::sadd_with_overflow;
+    llvm::Value *Carry, *Sum;
+
+    if (XTy == YTy && XTy == RTy) {
+      Sum = EmitOverflowIntrinsic(*this, IntrinsicId, X, Y, Carry);
+
+      //DEBUG(dbgs() << "storing: ");
+      //DEBUG(Sum->getType()->print(dbgs()));
+      //DEBUG(dbgs() << " -> ");
+      //DEBUG(SumOutPtr.first->getType()->print(dbgs()));
+      //DEBUG(dbgs() << " ");
+      //DEBUG(dbgs() << llvm::Intrinsic::getName(llvm::Intrinsic::uadd_with_overflow, X->getType()));
+      //DEBUG(dbgs() << "\n");
+    } else if (TypeRepresentableAs(CGM.getContext(), XQTy, RQTy) &&
+               TypeRepresentableAs(CGM.getContext(), YQTy, RQTy)) {
+      if (XTy->isSignedIntegerType()) {
+        X = Builder.CreateSExt(X, RLTy);
+      } else {
+        X = Builder.CreateZExt(X, RLTy);
+      }
+
+      if (YTy->isSignedIntegerType()) {
+        Y = Builder.CreateSExt(Y, RLTy);
+      } else {
+        Y = Builder.CreateZExt(Y, RLTy);
+      }
+
+      Sum = EmitOverflowIntrinsic(*this, IntrinsicId, X, Y, Carry);
+    } else {
+      CGM.Error(E->getLocStart(),
+        "cannot generate code for this combination of argument types yet");
+      return GetUndefRValue(E->getType());
+    }
+
+    // If the result argument is a _Bool*, EmitPointerWithAlignment
+    // gives us an i8* instead of an i1*.  Therefore we need to
+    // zero-extend Sum (which is an i1) to i8 before storing it.
+    if (Sum->getType()->isIntegerTy(1))
+    {
+      Sum = Builder.CreateZExt(Sum, OutputLTy);
+    }
+    Builder.CreateAlignedStore(Sum, SumOutPtr.first, SumOutPtr.second);
+
+    return RValue::get(Carry);
+  }
+
   case Builtin::BI__builtin_uadd_overflow:
   case Builtin::BI__builtin_uaddl_overflow:
   case Builtin::BI__builtin_uaddll_overflow:
diff --git a/lib/Sema/SemaChecking.cpp b/lib/Sema/SemaChecking.cpp
index a8a7009..a191036 100644
--- a/lib/Sema/SemaChecking.cpp
+++ b/lib/Sema/SemaChecking.cpp
@@ -111,6 +111,36 @@ static bool SemaBuiltinAddressof(Sema &S, CallExpr *TheCall) {
   return false;
 }
 
+static bool SemaBuiltinOverflow(Sema &S, CallExpr *TheCall) {
+  if (checkArgCount(S, TheCall, 3))
+    return true;
+
+  // First two arguments should be integers.
+  for (unsigned i = 0; i < 2; i++)
+  {
+    Expr *Arg = TheCall->getArg(i);
+    QualType Ty = Arg->getType();
+    if (!Ty->isIntegerType()) {
+      S.Diag(Arg->getLocStart(), diag::err_overflow_builtin_must_be_int)
+        << Ty << Arg->getSourceRange();
+      return true;
+    }
+  }
+
+  // Third argument should be a pointer to an integer.
+  {
+    Expr *Arg = TheCall->getArg(2);
+    QualType Ty = Arg->getType();
+    const PointerType *PtrTy = Ty->getAs<PointerType>();
+    if (!(PtrTy && PtrTy->getPointeeType()->isIntegerType())) {
+      S.Diag(Arg->getLocStart(), diag::err_overflow_builtin_must_be_ptr_int)
+        << Ty << Arg->getSourceRange();
+    }
+  }
+
+  return false;
+}
+
 static void SemaBuiltinMemChkCall(Sema &S, FunctionDecl *FDecl,
 		                  CallExpr *TheCall, unsigned SizeIdx,
                                   unsigned DstSizeIdx) {
@@ -453,6 +483,12 @@ Sema::CheckBuiltinFunctionCall(FunctionDecl *FDecl, unsigned BuiltinID,
     if (SemaBuiltinAddressof(*this, TheCall))
       return ExprError();
     break;
+  case Builtin::BI__builtin_add_overflow:
+  case Builtin::BI__builtin_sub_overflow:
+  case Builtin::BI__builtin_mul_overflow:
+      if (SemaBuiltinOverflow(*this, TheCall))
+          return ExprError();
+      break;
   case Builtin::BI__builtin_operator_new:
   case Builtin::BI__builtin_operator_delete:
     if (!getLangOpts().CPlusPlus) {
